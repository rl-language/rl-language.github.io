# The inversion of control problem

When **Complex interactive programs** are subjected to [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) (**IOC**), they [become superlinearly harder](#the-mental-burden) to reason about, refactor and mantain.

Here are pratical examples real world code that got harder to reason about because subject to **IOC**:
* blender statefull [GHOST event manager](https://github.com/blender/blender/blob/main/source/blender/windowmanager/intern/wm_event_system.cc) . The event manager is statefull but can only act in response to call backs.
* anaconda installer statefull [UI pages](https://github.com/rhinstaller/anaconda/blob/main/pyanaconda/ui/gui/spokes/storage.py). Anaconda UI pages can interleave in any order, and the main loop if controlled by the rendering engine.
* google deep mind [hanabi](https://github.com/google-deepmind/hanabi-learning-environment/tree/master/hanabi_learning_environment). The game has inherently many things the player can do, and must offer serialization to tensor to train a neural network to play it. The main loop is owned by the machine learning components.
* lightzero 756 lines long implementation of [tic tac toe](https://github.com/opendilab/LightZero/blob/main/zoo/board_games/tictactoe/envs/tictactoe_env.py).


## Complex interactive programs
**Complex interactive programs** are programs that contains procedures that have graph like behaviours and:
* the graph is large (**Complex**).
* must await for some input from some other component of the system before they can decide how to evolve, AND the user cares about their content. (**interactive**). The source of input does not need to be a human, it can be any source, including randonmess.

Examples:

```{graphviz}
digraph CheckoutFlow {
    node [shape=box, style=filled, fillcolor=lightgray];

    Start -> CartReview;
    CartReview -> Login [label="Not Logged In"];
    CartReview -> AddressSelection [label="Already Logged In", style=dotted];

    Login -> AddressSelection;
    AddressSelection -> ShippingMethod;
    ShippingMethod -> PaymentMethod;
    PaymentMethod -> OrderReview;
    OrderReview -> ConfirmOrder;
    ConfirmOrder -> ReceiptPage;

    // Back edges
    Login -> CartReview [label="Back"];
    AddressSelection -> Login [label="Back"];
    ShippingMethod -> AddressSelection [label="Back"];
    PaymentMethod -> ShippingMethod [label="Back"];
    OrderReview -> PaymentMethod [label="Back"];
    ConfirmOrder -> OrderReview [label="Back"];

    // Error and conditional states
    AddressSelection -> InvalidAddress [label="Invalid", style=dashed];
    ShippingMethod -> ShippingUnavailable [label="Unavailable", style=dashed];
    PaymentMethod -> PaymentFailed [label="Invalid Card", style=dashed];
    ConfirmOrder -> OrderFailed [label="Payment Error", style=dashed];

    // Grouping
    subgraph cluster_errors {
        style=dashed;
        color=red;
        label="Errors / Exceptions";
        InvalidAddress;
        ShippingUnavailable;
        PaymentFailed;
        OrderFailed;
    }

    subgraph cluster_flow {
        label="Main Checkout Flow";
        color=black;
        Start;
        CartReview;
        Login;
        AddressSelection;
        ShippingMethod;
        PaymentMethod;
        OrderReview;
        ConfirmOrder;
        ReceiptPage;
    }
}

```

* **Webstore checkout page**: when a user clicks on the payment mechanism of a web page, the pages they will be shown will depend on what they have filled into previous pages. Some pages are unique to certain payment circuits. If the user has specified they live in a different country some extra data can be requested. The user is allowed to navigate back to previous pages.
* **Installer wizards**: the user selection of conponents to install impacts the future pages they will be shown and extra data they are required to provide.
* **Online govermental forms**: the goverment cares not about your code quality, and if they assert that a user must fill 20 pages of documents that depend on previous documents they provided, that will be the way you implement it.
* **Video games**: Enemies in a first person shooter have a graph-like state machine that describe states such as `running`, `shooting`, `falling` that are driven by external events. Video games can contain hundred of such state machines at the same time, or the state machine can have hundreds of states.


Experienced programmers know that graphs should be avoided when are not necessary, but sometimes they are mandatory. The previous examples are all examples of situations where the business logic mandated the existence of graphs in the design of your solution.

## Inversion of control

The wikipedia page describes [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) in detail enough, so i suggest reading it before continuing, but as a recap: **inversion of control** arises when any program takes over the main loop of the process, and relegates programmer to implement callbacks that the main loop owner will call according to some logic.

This is pervasive and intended, graphical engines, web engines, reinforcement learning environments, and more, they all use this pattern to decouple the engine internals from the business logic implementation.


## The problem

Lets write again the problem statement

* When **Complex interactive programs** are subjected to [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control), they become superlinearly harder to reason about, refactor and mantain.

The assertion relies on the observation that giving up the main loop in a **Interactive system** (complex or not), entails that the program will be turned into a [state machine](https://en.wikipedia.org/wiki/Automata-based_programming), unless the programming language has some mechanism to solve the problem.

Let us make a example, say we have a python **Interactive program** such a a implementation of tic tac toe that owns the main loop.

```python
def play():
    board = Board()
    while not board.full():
        (x, y) = query_some_input()
        board.set_cell(x, y, board.current_player)
        if board.three_in_a_line():
            return
        board.switch_current_player()
```

What happens to it if the language did not had facilities such coroutines or similar constructs (which is the case in `C`), and we had to give up the main loop to say, a graphical engine?

The only viable implementation would be a class and that can be updated at will by the graphical engine whenever the user clicks on a cell.

```python
class TicTacToe:
  def __init__(self):
    self.board = Board()
    self.next_resumption_point = NormalTurn

  def update(self, x: int, y: int):
    self.board.set_cell(x, y, self.board.current_player)

    if self.board.three_in_a_line():
      self.next_resumption_point == Ended

  def is_done():
      return self.next_resumption_point == Ended

class Engine:
    ...
    def run():
      game = TicTacToe()
      while True:
          inputs = poll_input()
          if inputs.clicked_on_screen:
            game.update(inputs.x, inputs.y)
          render_frame(game.board)
```

This looked simple enough. Let us compose it into a more complex **interactive sequence**. Before looking at the solution.

```python
# plays up to 4 times
def play_twice():
    game1 = TicTacToe()
    while not game1.is_done():
        (x, y) = user_input
        game1.update(x, y)

    play_again = user_input()
    if play_again:
        game2 = TicTacToe()
        while not game2.is_done():
            (x, y) = user_input
            game2.update(x, y)
```

The class version is:

```
class PlayTwice:
    def __init__(self):
        self.game1 = TicTacToe()
        self.game2 = None
        self.resume_index = Start

    def update(*args):
        if self.resume_index == Start:
            (x, y) = args
            self.game1.update(x, y)
            if self.game1.board.is_done():
                self.resume_index = Question
            return
        if self.resume_index == Question:
            (play_again) = args
            if play_again:
                self.resume_index = SecondGame
                self.game2 = TicTacToe()
            else:
                self.resume_index = End
            return
        if self.resume_index == SecondGame:
            (x, y) = args
            self.game2.update(x, y)
            if self.game2.board.is_done():
                self.resume_index = End
            return
```

As you can see, turning this functions into classes by hand yields very quickly very ugly code.
As an exercise, convert into a class the following piece of code:

```python
# plays one game, then asks the user if they whish play again.
def play_four_times()
    game1 = PlayTwice()
    while not game1.resume_index == End:
        game1.update(user_input)

    play_again = user_input()
    if play_again:
        game2 = PlayTwice()
        while not game2.resume_index == End:
            game2.update(user_input)
```

Hint, the graph rappresenting the state is

```{graphviz}
digraph PlayFourTimes {
    node [shape=ellipse, style=filled, fillcolor=lightyellow];

    // States for first PlayTwice
    S0 [label="Start"];
    G1 [label="Play Game 1"];
    Q1 [label="Ask to Play Again?"];
    G2 [label="Play Game 2"];
    PT1_END [label="End of First PlayTwice"];

    // Transition to second PlayTwice
    Q2 [label="Ask to Play Again?"];
    G3 [label="Play Game 3"];
    Q3 [label="Ask to Play Again?"];
    G4 [label="Play Game 4"];
    END [label="Final End"];

    // First PlayTwice
    S0 -> G1;
    G1 -> Q1 [label="game1 complete"];
    Q1 -> G2 [label="yes"];
    Q1 -> PT1_END [label="no"];
    G2 -> PT1_END [label="game2 complete"];

    // After First PlayTwice
    PT1_END -> Q2;

    // Second PlayTwice (only if Q2 says yes)
    Q2 -> G3 [label="yes"];
    Q2 -> END [label="no"];

    G3 -> Q3 [label="game3 complete"];
    Q3 -> G4 [label="yes"];
    Q3 -> END [label="no"];
    G4 -> END [label="game4 complete"];
}
```

### The mental burden
I think that it is intuitive to any programmer that apporaching the problem this way does not scale. The conversion between the function and the class is actually linear and a well known pattern that implements a state machine.

Of course we are not the first to notice such problem, this problem is related but not equivalent to [callback hell](http://callbackhell.com), and the always green [non strutured programming](https://en.wikipedia.org/wiki/Non-structured_programming), since managing the state machine in complex programs is like managing the program counter manually with jumps.

The superlinearity arises from mantainance. Every time you have to modifying in any way the class version of the code you have to remember how the state got expanded out from the original imperative code, and therefore each modification almost always require to reason about the whole class instead of consindering the control flow locally, turning the mental cost of mantaining such datastrucutre into a mental O(num requested inputs * number of refactoring).

Sometimes the number of times the program requests a input is low, like in the case of tic tac toe, sometimes the you almost never change the code after the first time you write it, in those situations you don't suffer much the **inversion fo control problem**.


## Mitigations: coroutines

The most common solution to the problem are asyncronous language features.
In particular [co-routines](https://en.wikipedia.org/wiki/Coroutine), depending on their implementation, can sometimes fully solve the problem.

```python
def play(board):
    while not board.full():
        (x, y) = yield()
        board.set_cell(x, y, board.current_player)
        if board.three_in_a_line:
            return
        board.switch_current_player()


class Engine:
    ...
  def run():
    board = Board()
    game = play(board)
    while True:
      inputs = poll_input()
      if inputs.clicked_on_screen:
        game.update(inputs.x, inputs.y)
      render_frame(game.board)
```

Indeed, coroutines do exactly what we did by hand. They turned the imperative code into something that could be stopped and started according to the logic of the main loop holder.

## The limits of co-routines

Typechecked languages coroutines are often less able to cope with **Complex Interactive Programs**. Unchecked interpeted languages such as python can perform expensive introspection tricks to solve the problem. Still, every coroutine implementation I am aware of suffer from at least one of these issues:

* **Cannot copy coroutines** I am not aware of any implementation of coroutines that allows for copiable coroutines. This means that if you have a **Interactive Program** that you wish to copy, say chess, that implementation must be a regular class instead. Copying chess is critical to techinques such as [monte carlo tree search](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search).

* **Cannot inspect the content of the coroutine** Most typechecked implementations, such as the Cpp ones, do not  allow to inspect the content of the coroutine without exfiltrating the pointer to the variables somehow. Inspecting coroutines is critical when the state of the coroutine is relevant to the decision maker, for example in reinforcement learning you would like to deliver parts of the coroutine state to the GPU for the GPU to take decisions.

* **Cannot compose coroutines** Most languages are able to compose coroutines with stackfull coroutines implementations, but some languages such as Lua or CPP before Cpp 20 (boost coro), do not. Composing coroutines is critical when the size of the **Interactive Program** scales.

Notice that if you do need one of these properties and you do not have acccess to them, you are **forced** to write the class just like we did before, suffering the full **Inversion of Control problem**.
